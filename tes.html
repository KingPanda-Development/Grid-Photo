<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ENTER — Dark Realm (KingPanda)</title>
<meta name="description" content="Main 3D landing: devil dark red theme, particles, animated ground, enter button." />
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;700;900&display=swap" rel="stylesheet">
<style>
  :root{--bg:#060406;--card:rgba(255,255,255,0.03);--accent:#ff3b3b;--accent-2:#8b0000}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#050003,#120006);color:#fff;overflow:hidden}
  #canvas-wrap{position:absolute;inset:0;z-index:1;pointer-events:none}
  /* top UI */
  .topbar{position:fixed;left:20px;top:18px;z-index:60;pointer-events:auto}
  .brand{font-weight:900;letter-spacing:1px}

  /* center menu */
  .menu{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:60;display:flex;flex-direction:column;gap:18px;align-items:center;pointer-events:auto}
  .title{font-size:48px;font-weight:900;line-height:1;letter-spacing:4px;text-transform:uppercase;color:var(--accent);text-shadow:0 8px 40px rgba(139,0,0,0.28)}
  .subtitle{font-size:14px;opacity:0.8;color:#f6dede}
  .enter-btn{background:linear-gradient(180deg,#ff4b4b,#b30000);border:none;padding:16px 44px;border-radius:999px;font-size:16px;font-weight:800;cursor:pointer;color:white;box-shadow:0 12px 40px rgba(139,0,0,0.35);transition:transform .15s ease,box-shadow .15s ease;pointer-events:auto}
  .enter-btn:hover{transform:translateY(-4px);box-shadow:0 18px 60px rgba(255,59,59,0.44)}

  /* bottom hint */
  .hint{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;font-size:12px;opacity:0.7;z-index:60}

  /* overlay when entering */
  .overlay{position:fixed;inset:0;background:linear-gradient(180deg,rgba(11,0,0,0.45),rgba(0,0,0,0.85));display:flex;align-items:center;justify-content:center;z-index:70;opacity:0;pointer-events:none;transition:opacity .45s ease}
  .overlay.show{opacity:1;pointer-events:auto}
  .overlay .box{background:rgba(0,0,0,0.4);padding:22px 28px;border-radius:12px;text-align:center;border:1px solid rgba(255,255,255,0.03)}
  .overlay h2{margin:0 0 8px 0;color:#ffdddd}

  @media (max-width:600px){ .title{font-size:28px} .enter-btn{padding:12px 28px} }
</style>
</head>
<body>
  <div id="canvas-wrap"></div>
  <div class="topbar"><div class="brand">KingPanda</div></div>
  <div class="menu">
    <div class="title">ENTER DARK REALM</div>
    <div class="subtitle">A compact 3D landing — click to enter</div>
    <button id="enter" class="enter-btn">ENTER WORLD</button>
  </div>
  <div class="hint">Use mouse / touch to orbit</div>

  <div id="overlay" class="overlay"><div class="box"><h2>Entering...</h2><p style="opacity:0.9">Welcome to the dark realm. Loading scene...</p></div></div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.152.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.152.0/examples/jsm/controls/OrbitControls.js';

    // renderer + scene + camera
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    const mount = document.getElementById('canvas-wrap');
    mount.appendChild(renderer.domElement);
    // IMPORTANT: keep canvas pointer-events NONE initially so UI is clickable
    renderer.domElement.style.pointerEvents = 'none';
    renderer.domElement.style.zIndex = '2';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050003);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 200);
    camera.position.set(0, 3.6, 10);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 2.2; controls.maxDistance = 30;
    // disable controls until user enters
    controls.enabled = false;

    // lights
    const amb = new THREE.AmbientLight(0x441111, 0.6); scene.add(amb);
    const dir = new THREE.DirectionalLight(0xff6b6b, 1.2); dir.position.set(5,10,2); scene.add(dir);

    // fog
    scene.fog = new THREE.FogExp2(0x060004, 0.03);

    // ----- ground (glowy, displacement-like using vertex shader) -----
    const planeGeo = new THREE.PlaneGeometry(40,40,200,200);
    const groundMat = new THREE.ShaderMaterial({
      uniforms: {
        uTime:{value:0}, uColorA:{value:new THREE.Color(0x330000)}, uColorB:{value:new THREE.Color(0x2b0000)}, uGlow:{value:1.0}
      },
      vertexShader: `
        uniform float uTime; varying vec2 vUv; varying float vH;
        void main(){ vUv = uv; vec3 p = position; float d = length(position.xz); float h = 0.6 * sin(3.0 * position.x + uTime * 1.3) + 0.4 * cos(2.0 * position.y + uTime*0.9) + 0.2 * sin(5.0 * d - uTime*1.1); p.z += h*0.25; vH = h; gl_Position = projectionMatrix * modelViewMatrix * vec4(p,1.0); }
      `,
      fragmentShader: `
        varying vec2 vUv; varying float vH; uniform vec3 uColorA; uniform vec3 uColorB; uniform float uGlow;
        void main(){ vec3 c = mix(uColorA, uColorB, vUv.y + vH*0.2); float g = smoothstep(-0.2, 0.8, vH)*uGlow; gl_FragColor = vec4(c + vec3(g*0.35, g*0.08, g*0.08), 1.0); }
      `,
      side: THREE.DoubleSide
    });
    const ground = new THREE.Mesh(planeGeo, groundMat); ground.rotation.x = -Math.PI/2; ground.position.y = -2; scene.add(ground);

    // ----- ember particles (Points with custom vertex colors) -----
    const particleCount = 1200;
    const positions = new Float32Array(particleCount*3);
    const sizes = new Float32Array(particleCount);
    const colors = new Float32Array(particleCount*3);
    for(let i=0;i<particleCount;i++){
      const r = Math.random()*6.0;
      const ang = Math.random()*Math.PI*2;
      const x = Math.cos(ang)*r + (Math.random()-0.5)*0.6;
      const y = Math.random()*3.2 - 0.2;
      const z = Math.sin(ang)*r + (Math.random()-0.5)*0.6;
      positions[i*3]=x; positions[i*3+1]=y; positions[i*3+2]=z;
      sizes[i]=2.0 + Math.random()*6.0;
      const t = Math.random(); colors[i*3]=1.0; colors[i*3+1]=0.2 + t*0.6; colors[i*3+2]=0.05;
    }
    const pGeo = new THREE.BufferGeometry();
    pGeo.setAttribute('position', new THREE.BufferAttribute(positions,3));
    pGeo.setAttribute('aSize', new THREE.BufferAttribute(sizes,1));
    pGeo.setAttribute('color', new THREE.BufferAttribute(colors,3));

    const particleMat = new THREE.ShaderMaterial({
      uniforms:{ uTime:{value:0}, uPixelRatio:{value:window.devicePixelRatio} },
      vertexShader: `
        attribute float aSize; attribute vec3 color; varying vec3 vColor; uniform float uTime; void main(){ vColor = color; vec3 p = position; float rise = sin(uTime*1.2 + p.x*0.5) * 0.4 + abs(p.y)*0.05; vec4 mvPos = modelViewMatrix * vec4(p + vec3(0, rise, 0), 1.0); gl_PointSize = aSize * (200.0 / -mvPos.z) * (1.0 + sin(uTime*3.0 + position.x)); gl_Position = projectionMatrix * mvPos; }
      `,
      fragmentShader: `
        varying vec3 vColor; void main(){ vec2 c = gl_PointCoord - 0.5; float d = length(c); if(d>0.5) discard; float alpha = smoothstep(0.5,0.0,d); vec3 col = vColor; gl_FragColor = vec4(col, alpha); }
      `,
      transparent:true, depthWrite:false, vertexColors:true
    });
    const particles = new THREE.Points(pGeo, particleMat); scene.add(particles);

    // ----- central obelisk (dark glowing pillar) -----
    const pillarGeo = new THREE.CylinderGeometry(0.6,1.4,6,32,1,true);
    const pillarMat = new THREE.MeshStandardMaterial({color:0x140505, metalness:0.5, roughness:0.4});
    const pillar = new THREE.Mesh(pillarGeo, pillarMat); pillar.position.y=1; scene.add(pillar);
    // inner core glow
    const coreGeo = new THREE.CylinderGeometry(0.4,0.4,5.4,32);
    const coreMat = new THREE.MeshBasicMaterial({color:0xff3b3b, transparent:true, opacity:0.18});
    const core = new THREE.Mesh(coreGeo, coreMat); core.position.y=1; scene.add(core);

    // ----- decorative rings -----
    const ringMat = new THREE.MeshBasicMaterial({color:0xff6b6b, transparent:true, opacity:0.12});
    for(let i=0;i<3;i++){ const r = new THREE.Mesh(new THREE.TorusGeometry(3 + i*0.9,0.04,8,120), ringMat); r.position.y = 1 + i*0.8; r.rotation.x = (i%2?0.2: -0.2); scene.add(r); }

    // camera idle movement
    let idleTime = 0;

    // animation loop
    const clock = new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();
      groundMat.uniforms.uTime.value = t*0.9;
      particleMat.uniforms.uTime.value = t*0.9;
      // subtle pillar glow pulse
      core.material.opacity = 0.12 + Math.abs(Math.sin(t*1.6))*0.08;
      // rotate rings
      scene.traverse(o=>{ if(o.geometry && o.geometry.type==='TorusGeometry'){ o.rotation.z += 0.002; }});
      // idle camera sway
      idleTime += 0.0012;
      camera.position.x = Math.sin(idleTime*0.6)*0.6;
      camera.position.y = 3.6 + Math.sin(idleTime*0.3)*0.12;
      controls.update(); renderer.render(scene, camera);
    }
    animate();

    // ----- interactions: ENTER button -----
    const enter = document.getElementById('enter'); const overlay = document.getElementById('overlay');
    enter.addEventListener('click', ()=>{
      // enable canvas interaction and controls once the user explicitly enters
      renderer.domElement.style.pointerEvents = 'auto';
      controls.enabled = true;

      overlay.classList.add('show');
      // camera zoom-in animation towards pillar
      const start = camera.position.clone(); const target = new THREE.Vector3(0,2.2,4.0);
      const startT = performance.now(); const dur = 900;
      function frame(){ const now = performance.now(); let p = (now - startT)/dur; if(p>1) p=1; const eased = (1 - Math.cos(Math.PI * p)) / 2; camera.position.lerpVectors(start, target, eased); camera.lookAt(0,1.6,0); if(p<1) requestAnimationFrame(frame); else { setTimeout(()=>{ overlay.classList.remove('show'); enter.innerText='WELCOME'; enter.disabled = true; enter.style.cursor='default'; }, 700); } }
      frame();
    });

    // responsive
    window.addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

    // safety fallback
    if(!renderer.capabilities.isWebGL2 && !renderer.capabilities.isWebGL){ document.body.innerHTML = '<div style="padding:40px;color:#fff">WebGL tidak tersedia — gunakan browser modern.</div>'; }

  </script>
</body>
</html>
